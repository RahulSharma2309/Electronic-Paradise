name: CD Pipeline - Deploy to Kubernetes

on:
  pull_request:
    types: [closed]
    branches:
      - main
  workflow_dispatch: # Allow manual trigger
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - prod

env:
  KUBERNETES_CONTEXT: docker-desktop

jobs:
  # ============================================================================
  # PHASE 1: Determine Deployment Environment
  # ============================================================================
  determine-environment:
    runs-on: ubuntu-latest
    # Only run if:
    # 1. PR was merged AND has 'deploy-to-staging' or 'deploy-to-prod' label (deployment PRs created by CI)
    # 2. OR manually triggered via workflow_dispatch
    if: |
      (github.event.pull_request.merged == true && 
       (contains(github.event.pull_request.labels.*.name, 'deploy-to-staging') || 
        contains(github.event.pull_request.labels.*.name, 'deploy-to-prod'))) ||
      github.event_name == 'workflow_dispatch'
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      namespace: ${{ steps.env.outputs.namespace }}
    steps:
      - name: Determine environment from PR labels or input
        id: env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          else
            # Check PR labels for deploy-to-prod
            PR_LABELS="${{ join(github.event.pull_request.labels.*.name, ' ') }}"
            if echo "$PR_LABELS" | grep -q "deploy-to-prod"; then
              ENV="prod"
            else
              ENV="staging"
            fi
          fi
          
          if [ "$ENV" == "prod" ]; then
            NAMESPACE="prod"
          else
            NAMESPACE="staging"
          fi
          
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "namespace=${NAMESPACE}" >> $GITHUB_OUTPUT
          echo "ðŸŽ¯ Deploying to: ${ENV} (namespace: ${NAMESPACE})"

  # ============================================================================
  # PHASE 2: Prepare Deployment
  # ============================================================================
  prepare-deployment:
    needs: determine-environment
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      git-sha: ${{ steps.git.outputs.sha }}
      repo-owner: ${{ steps.repo.outputs.owner }}
      environment: ${{ needs.determine-environment.outputs.environment }}
      namespace: ${{ needs.determine-environment.outputs.namespace }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract version from deployment files
        id: version
        run: |
          # Extract version from deployment YAML files
          DEPLOYMENT_FILE="infra/k8s/${{ needs.determine-environment.outputs.namespace }}/deployments/auth-service/deployment.yaml"
          if [ -f "$DEPLOYMENT_FILE" ]; then
            IMAGE_TAG=$(grep -E "image:.*:v[0-9]" "$DEPLOYMENT_FILE" | head -1 | sed -E 's/.*:v([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
            if [ -n "$IMAGE_TAG" ]; then
              echo "version=${IMAGE_TAG}" >> $GITHUB_OUTPUT
              echo "ðŸ“Š Version: ${IMAGE_TAG}"
            else
              # Fallback to latest
              echo "version=latest" >> $GITHUB_OUTPUT
              echo "ðŸ“Š Version: latest (fallback)"
            fi
          else
            echo "version=latest" >> $GITHUB_OUTPUT
            echo "ðŸ“Š Version: latest (fallback)"
          fi

      - name: Get Git SHA
        id: git
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "ðŸ”– SHA: $SHORT_SHA"

      - name: Get repo owner
        id: repo
        run: |
          OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          echo "owner=$OWNER" >> $GITHUB_OUTPUT

  # ============================================================================
  # PHASE 2: Verify Images Exist
  # ============================================================================
  verify-images:
    needs: [determine-environment, prepare-deployment]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    strategy:
      fail-fast: false
      matrix:
        service:
          - { name: "auth", image: "electronic-paradise-auth" }
          - { name: "user", image: "electronic-paradise-user" }
          - { name: "product", image: "electronic-paradise-product" }
          - { name: "order", image: "electronic-paradise-order" }
          - { name: "payment", image: "electronic-paradise-payment" }
          - { name: "gateway", image: "electronic-paradise-gateway" }
          - { name: "frontend", image: "electronic-paradise-frontend" }
    steps:
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify image exists
        run: |
          VERSION="${{ needs.prepare-deployment.outputs.version }}"
          SHA="${{ needs.prepare-deployment.outputs.git-sha }}"
          OWNER="${{ needs.prepare-deployment.outputs.repo-owner }}"
          
          # Try versioned tag first
          if [ "$VERSION" != "latest" ]; then
            IMAGE_TAG="ghcr.io/${OWNER}/${{ matrix.service.image }}:v${VERSION}"
            echo "Checking for image: ${IMAGE_TAG}"
            if docker manifest inspect "${IMAGE_TAG}" > /dev/null 2>&1; then
              echo "âœ… Image found: ${IMAGE_TAG}"
              exit 0
            fi
          fi
          
          # Fallback to latest
          IMAGE_TAG="ghcr.io/${OWNER}/${{ matrix.service.image }}:latest"
          echo "Falling back to: ${IMAGE_TAG}"
          docker manifest inspect "${IMAGE_TAG}" || exit 1
          echo "âœ… Image found: ${IMAGE_TAG}"

  # ============================================================================
  # PHASE 3: Deploy to Kubernetes
  # ============================================================================
  deploy-to-kubernetes:
    needs: [prepare-deployment, verify-images]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    environment:
      name: ${{ needs.prepare-deployment.outputs.environment }}
      url: ${{ needs.prepare-deployment.outputs.environment == 'prod' && 'http://api.electronic-paradise.local' || 'http://staging.electronic-paradise.local' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubectl context
        run: |
          # For Docker Desktop Kubernetes (local)
          # In production, you would configure cloud provider credentials here
          echo "Configuring kubectl for Docker Desktop..."
          # kubectl config set-context docker-desktop
          # kubectl config use-context docker-desktop

      - name: Verify namespace exists
        run: |
          NAMESPACE="${{ needs.prepare-deployment.outputs.namespace }}"
          kubectl get namespace "${NAMESPACE}" || \
          kubectl create namespace "${NAMESPACE}"

      - name: Create image pull secret (if needed)
        run: |
          NAMESPACE="${{ needs.prepare-deployment.outputs.namespace }}"
          # Check if secret already exists
          if ! kubectl get secret ghcr-secret -n "${NAMESPACE}" > /dev/null 2>&1; then
            echo "âš ï¸ ghcr-secret not found in ${NAMESPACE} namespace"
            echo "Please create it manually:"
            echo "kubectl create secret docker-registry ghcr-secret \\"
            echo "  --docker-server=ghcr.io \\"
            echo "  --docker-username=YOUR_USERNAME \\"
            echo "  --docker-password=YOUR_TOKEN \\"
            echo "  --namespace=${NAMESPACE}"
          else
            echo "âœ… Image pull secret exists"
          fi

      - name: Apply Kubernetes manifests
        run: |
          NAMESPACE="${{ needs.prepare-deployment.outputs.namespace }}"
          ENV="${{ needs.prepare-deployment.outputs.environment }}"
          echo "ðŸš€ Applying Kubernetes manifests to ${ENV} (namespace: ${NAMESPACE})..."
          
          # Apply in order: namespaces, RBAC, configmaps, secrets, deployments
          kubectl apply -f infra/k8s/${NAMESPACE}/namespaces/ || true
          kubectl apply -f infra/k8s/${NAMESPACE}/rbac/
          kubectl apply -f infra/k8s/${NAMESPACE}/configmaps/
          kubectl apply -f infra/k8s/${NAMESPACE}/secrets/ || true
          kubectl apply -f infra/k8s/${NAMESPACE}/deployments/
          kubectl apply -f infra/k8s/${NAMESPACE}/ingress/ || true
          kubectl apply -f infra/k8s/${NAMESPACE}/storage/ || true

      - name: Wait for deployments to be ready
        run: |
          NAMESPACE="${{ needs.prepare-deployment.outputs.namespace }}"
          echo "â³ Waiting for all deployments to be ready in ${NAMESPACE}..."
          kubectl wait --for=condition=available --timeout=300s \
            deployment/auth-service \
            deployment/user-service \
            deployment/product-service \
            deployment/order-service \
            deployment/payment-service \
            deployment/gateway \
            deployment/frontend \
            -n "${NAMESPACE}" || true

      - name: Get deployment status
        run: |
          NAMESPACE="${{ needs.prepare-deployment.outputs.namespace }}"
          ENV="${{ needs.prepare-deployment.outputs.environment }}"
          echo "## ðŸ“Š Deployment Status - ${ENV}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          kubectl get deployments -n "${NAMESPACE}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸš€ Pods Status" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n "${NAMESPACE}" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # PHASE 4: Smoke Tests
  # ============================================================================
  smoke-tests:
    needs: [deploy-to-kubernetes]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubectl context
        run: |
          echo "Configuring kubectl for Docker Desktop..."
          # kubectl config use-context docker-desktop

      - name: Wait for services to be ready
        run: |
          echo "Waiting for services to be ready..."
          sleep 30  # Give services time to start

      - name: Run smoke tests
        run: |
          NAMESPACE="${{ needs.prepare-deployment.outputs.namespace }}"
          ENV="${{ needs.prepare-deployment.outputs.environment }}"
          echo "ðŸ§ª Running smoke tests against ${ENV} environment..."
          
          # Test gateway health endpoint
          GATEWAY_POD=$(kubectl get pods -n "${NAMESPACE}" -l app=gateway -o jsonpath='{.items[0].metadata.name}' || echo "")
          
          if [ -z "$GATEWAY_POD" ]; then
            echo "âš ï¸ Gateway pod not found, skipping gateway health check"
          else
            echo "Testing gateway health endpoint..."
            kubectl exec -n "${NAMESPACE}" "$GATEWAY_POD" -- \
              curl -f http://localhost:80/api/health || echo "âš ï¸ Gateway health check failed"
          fi
          
          # Test auth-service health endpoint
          AUTH_POD=$(kubectl get pods -n "${NAMESPACE}" -l app=auth-service -o jsonpath='{.items[0].metadata.name}' || echo "")
          
          if [ -z "$AUTH_POD" ]; then
            echo "âš ï¸ Auth service pod not found, skipping auth health check"
          else
            echo "Testing auth-service health endpoint..."
            kubectl exec -n "${NAMESPACE}" "$AUTH_POD" -- \
              curl -f http://localhost:80/api/health || echo "âš ï¸ Auth service health check failed"
          fi
          
          echo "âœ… Smoke tests completed"

      - name: Get service endpoints
        run: |
          NAMESPACE="${{ needs.prepare-deployment.outputs.namespace }}"
          echo "## ðŸ”— Service Endpoints" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          kubectl get services -n "${NAMESPACE}" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # PHASE 5: Deployment Summary
  # ============================================================================
  deployment-summary:
    needs: [prepare-deployment, deploy-to-kubernetes, smoke-tests]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Deployment Summary
        run: |
          ENV="${{ needs.prepare-deployment.outputs.environment }}"
          NAMESPACE="${{ needs.prepare-deployment.outputs.namespace }}"
          echo "## ðŸŽ‰ Deployment to ${ENV^} Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.prepare-deployment.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Git SHA:** ${{ needs.prepare-deployment.outputs.git-sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${ENV^}" >> $GITHUB_STEP_SUMMARY
          echo "**Namespace:** ${NAMESPACE}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ Deployed Services:" >> $GITHUB_STEP_SUMMARY
          echo "- Auth Service" >> $GITHUB_STEP_SUMMARY
          echo "- User Service" >> $GITHUB_STEP_SUMMARY
          echo "- Product Service" >> $GITHUB_STEP_SUMMARY
          echo "- Order Service" >> $GITHUB_STEP_SUMMARY
          echo "- Payment Service" >> $GITHUB_STEP_SUMMARY
          echo "- Gateway" >> $GITHUB_STEP_SUMMARY
          echo "- Frontend" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. Verify services are running: \`kubectl get pods -n ${NAMESPACE}\`" >> $GITHUB_STEP_SUMMARY
          echo "2. Check logs: \`kubectl logs -n ${NAMESPACE} deployment/<service-name>\`" >> $GITHUB_STEP_SUMMARY
          if [ "$ENV" == "prod" ]; then
            echo "3. Access frontend: http://app.electronic-paradise.local" >> $GITHUB_STEP_SUMMARY
            echo "4. Access API: http://api.electronic-paradise.local" >> $GITHUB_STEP_SUMMARY
          else
            echo "3. Access frontend: http://staging.electronic-paradise.local" >> $GITHUB_STEP_SUMMARY
            echo "4. Access API: http://api.staging.electronic-paradise.local" >> $GITHUB_STEP_SUMMARY
          fi
