name: CD Pipeline - Deploy to Staging

on:
  push:
    branches:
      - main
    paths:
      - 'services/**'
      - 'gateway/**'
      - 'frontend/**'
      - 'infra/k8s/**'
      - '.github/workflows/cd-staging.yml'
  workflow_dispatch: # Allow manual trigger

env:
  KUBERNETES_NAMESPACE: staging
  KUBERNETES_CONTEXT: docker-desktop

jobs:
  # ============================================================================
  # PHASE 1: Prepare Deployment
  # ============================================================================
  prepare-deployment:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      git-sha: ${{ steps.git.outputs.sha }}
      repo-owner: ${{ steps.repo.outputs.owner }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate version
        id: version
        run: |
          chmod +x ./scripts/get-next-version.sh
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          VERSION=$(./scripts/get-next-version.sh "$BRANCH_NAME")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ðŸ“Š Version: $VERSION"

      - name: Get Git SHA
        id: git
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "ðŸ”– SHA: $SHORT_SHA"

      - name: Get repo owner
        id: repo
        run: |
          OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          echo "owner=$OWNER" >> $GITHUB_OUTPUT

  # ============================================================================
  # PHASE 2: Verify Images Exist
  # ============================================================================
  verify-images:
    needs: prepare-deployment
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    strategy:
      fail-fast: false
      matrix:
        service:
          - { name: "auth", image: "electronic-paradise-auth" }
          - { name: "user", image: "electronic-paradise-user" }
          - { name: "product", image: "electronic-paradise-product" }
          - { name: "order", image: "electronic-paradise-order" }
          - { name: "payment", image: "electronic-paradise-payment" }
          - { name: "gateway", image: "electronic-paradise-gateway" }
          - { name: "frontend", image: "electronic-paradise-frontend" }
    steps:
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify image exists
        run: |
          VERSION="${{ needs.prepare-deployment.outputs.version }}"
          SHA="${{ needs.prepare-deployment.outputs.git-sha }}"
          OWNER="${{ needs.prepare-deployment.outputs.repo-owner }}"
          
          # Try production tag first, then alpha tag
          IMAGE_TAG="ghcr.io/${OWNER}/${{ matrix.service.image }}:v${VERSION}"
          echo "Checking for image: ${IMAGE_TAG}"
          
          if ! docker manifest inspect "${IMAGE_TAG}" > /dev/null 2>&1; then
            # Fallback to latest
            IMAGE_TAG="ghcr.io/${OWNER}/${{ matrix.service.image }}:latest"
            echo "Falling back to: ${IMAGE_TAG}"
            docker manifest inspect "${IMAGE_TAG}" || exit 1
          fi
          
          echo "âœ… Image found: ${IMAGE_TAG}"

  # ============================================================================
  # PHASE 3: Deploy to Kubernetes Staging
  # ============================================================================
  deploy-to-staging:
    needs: [prepare-deployment, verify-images]
    runs-on: self-hosted  # Uses self-hosted runner on local machine
    permissions:
      contents: read
    environment:
      name: staging
      url: http://staging.electronic-paradise.local
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubectl context
        shell: pwsh
        run: |
          Write-Host "Configuring kubectl for Docker Desktop..." -ForegroundColor Green
          
          # Verify kubectl is available
          kubectl version --client
          
          # Check current context
          $currentContext = kubectl config current-context
          Write-Host "Current context: $currentContext" -ForegroundColor Yellow
          
          # Switch to docker-desktop context
          kubectl config use-context docker-desktop
          
          # Verify context switch
          $newContext = kubectl config current-context
          Write-Host "New context: $newContext" -ForegroundColor Green
          
          # Verify cluster access
          kubectl cluster-info
          kubectl get nodes

      - name: Verify namespace exists
        shell: pwsh
        run: |
          $namespace = "${{ env.KUBERNETES_NAMESPACE }}"
          Write-Host "Checking namespace: $namespace" -ForegroundColor Yellow
          
          $exists = kubectl get namespace $namespace 2>&1
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Namespace does not exist, creating..." -ForegroundColor Yellow
            kubectl create namespace $namespace
          } else {
            Write-Host "Namespace already exists" -ForegroundColor Green
          }

      - name: Update image tags in deployments
        shell: pwsh
        run: |
          $VERSION = "${{ needs.prepare-deployment.outputs.version }}"
          $OWNER = "${{ needs.prepare-deployment.outputs.repo-owner }}"
          
          Write-Host "Updating image tags to version: v$VERSION" -ForegroundColor Green
          Write-Host "Repository owner: $OWNER" -ForegroundColor Yellow
          
          # Find all deployment.yaml files
          $deploymentFiles = Get-ChildItem -Path "infra/k8s/staging/deployments" -Recurse -Filter "deployment.yaml"
          
          foreach ($file in $deploymentFiles) {
            Write-Host "Processing: $($file.FullName)" -ForegroundColor Cyan
            
            $content = Get-Content $file.FullName -Raw
            
            # Determine service name from file path
            $serviceName = $file.Directory.Name
            
            # Map service names to image names
            $imageMap = @{
              "auth-service" = "electronic-paradise-auth"
              "user-service" = "electronic-paradise-user"
              "product-service" = "electronic-paradise-product"
              "order-service" = "electronic-paradise-order"
              "payment-service" = "electronic-paradise-payment"
              "gateway" = "electronic-paradise-gateway"
              "frontend" = "electronic-paradise-frontend"
            }
            
            $imageName = $imageMap[$serviceName]
            if (-not $imageName) {
              Write-Host "âš ï¸ Unknown service: $serviceName, skipping..." -ForegroundColor Yellow
              continue
            }
            
            # Build new image tag
            $newImageTag = "ghcr.io/$OWNER/$imageName`:$VERSION"
            
            # Replace image tag (handles various formats)
            $content = $content -replace "image:\s*ghcr\.io/[^/]+/$imageName:[^\s`"]+", "image: $newImageTag"
            
            # Save updated content
            Set-Content -Path $file.FullName -Value $content -NoNewline
            
            Write-Host "âœ… Updated $serviceName to $newImageTag" -ForegroundColor Green
          }
          
          Write-Host "`nAll deployment files updated!" -ForegroundColor Green

      - name: Apply Kubernetes manifests
        shell: pwsh
        run: |
          Write-Host "Applying Kubernetes manifests to staging namespace..." -ForegroundColor Green
          
          # Apply in order: namespaces, RBAC, configmaps, secrets, deployments
          Write-Host "Applying namespaces..." -ForegroundColor Yellow
          kubectl apply -f infra/k8s/staging/namespaces/ 2>&1 | Out-Null
          
          Write-Host "Applying RBAC..." -ForegroundColor Yellow
          kubectl apply -f infra/k8s/staging/rbac/
          
          Write-Host "Applying ConfigMaps..." -ForegroundColor Yellow
          kubectl apply -f infra/k8s/staging/configmaps/
          
          Write-Host "Applying Secrets..." -ForegroundColor Yellow
          kubectl apply -f infra/k8s/staging/secrets/ 2>&1 | Out-Null
          
          Write-Host "Applying Deployments..." -ForegroundColor Yellow
          kubectl apply -f infra/k8s/staging/deployments/
          
          Write-Host "Applying Ingress..." -ForegroundColor Yellow
          kubectl apply -f infra/k8s/staging/ingress/ 2>&1 | Out-Null
          
          Write-Host "Applying Storage..." -ForegroundColor Yellow
          kubectl apply -f infra/k8s/staging/storage/ 2>&1 | Out-Null
          
          Write-Host "âœ… All manifests applied!" -ForegroundColor Green

      - name: Wait for deployments to be ready
        shell: pwsh
        run: |
          Write-Host "Waiting for all deployments to be ready..." -ForegroundColor Yellow
          $namespace = "${{ env.KUBERNETES_NAMESPACE }}"
          
          $deployments = @(
            "auth-service",
            "user-service",
            "product-service",
            "order-service",
            "payment-service",
            "gateway",
            "frontend"
          )
          
          foreach ($deployment in $deployments) {
            Write-Host "Waiting for $deployment..." -ForegroundColor Cyan
            kubectl wait --for=condition=available --timeout=300s `
              deployment/$deployment `
              -n $namespace 2>&1 | Out-Null
            
            if ($LASTEXITCODE -eq 0) {
              Write-Host "âœ… $deployment is ready" -ForegroundColor Green
            } else {
              Write-Host "âš ï¸ $deployment may not be ready yet" -ForegroundColor Yellow
            }
          }
          
          Write-Host "`nAll deployments processed!" -ForegroundColor Green

      - name: Get deployment status
        shell: pwsh
        run: |
          $namespace = "${{ env.KUBERNETES_NAMESPACE }}"
          
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## ðŸ“Š Deployment Status`n"
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "``````"
          kubectl get deployments -n $namespace | Add-Content -Path $env:GITHUB_STEP_SUMMARY
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "``````"
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "`n## ðŸš€ Pods Status`n"
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "``````"
          kubectl get pods -n $namespace | Add-Content -Path $env:GITHUB_STEP_SUMMARY
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "``````"

  # ============================================================================
  # PHASE 4: Smoke Tests
  # ============================================================================
  smoke-tests:
    needs: [deploy-to-staging]
    runs-on: self-hosted  # Uses self-hosted runner on local machine
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubectl context
        shell: pwsh
        run: |
          kubectl config use-context docker-desktop

      - name: Wait for services to be ready
        shell: pwsh
        run: |
          Write-Host "Waiting for services to be ready..." -ForegroundColor Yellow
          Start-Sleep -Seconds 30

      - name: Run smoke tests
        shell: pwsh
        run: |
          Write-Host "Running smoke tests against staging environment..." -ForegroundColor Green
          $namespace = "${{ env.KUBERNETES_NAMESPACE }}"
          $testPassed = $true
          
          # Test gateway health endpoint
          Write-Host "`nTesting gateway health endpoint..." -ForegroundColor Cyan
          $gatewayPod = kubectl get pods -n $namespace -l app=gateway -o jsonpath='{.items[0].metadata.name}' 2>&1
          
          if ([string]::IsNullOrWhiteSpace($gatewayPod) -or $gatewayPod -match "error") {
            Write-Host "âš ï¸ Gateway pod not found, skipping gateway health check" -ForegroundColor Yellow
          } else {
            Write-Host "Gateway pod: $gatewayPod" -ForegroundColor Yellow
            $result = kubectl exec -n $namespace $gatewayPod -- curl -f http://localhost:80/api/health 2>&1
            if ($LASTEXITCODE -eq 0) {
              Write-Host "âœ… Gateway health check passed" -ForegroundColor Green
            } else {
              Write-Host "âš ï¸ Gateway health check failed" -ForegroundColor Yellow
              $testPassed = $false
            }
          }
          
          # Test auth-service health endpoint
          Write-Host "`nTesting auth-service health endpoint..." -ForegroundColor Cyan
          $authPod = kubectl get pods -n $namespace -l app=auth-service -o jsonpath='{.items[0].metadata.name}' 2>&1
          
          if ([string]::IsNullOrWhiteSpace($authPod) -or $authPod -match "error") {
            Write-Host "âš ï¸ Auth service pod not found, skipping auth health check" -ForegroundColor Yellow
          } else {
            Write-Host "Auth pod: $authPod" -ForegroundColor Yellow
            $result = kubectl exec -n $namespace $authPod -- curl -f http://localhost:80/api/health 2>&1
            if ($LASTEXITCODE -eq 0) {
              Write-Host "âœ… Auth service health check passed" -ForegroundColor Green
            } else {
              Write-Host "âš ï¸ Auth service health check failed" -ForegroundColor Yellow
              $testPassed = $false
            }
          }
          
          if ($testPassed) {
            Write-Host "`nâœ… Smoke tests completed successfully" -ForegroundColor Green
          } else {
            Write-Host "`nâš ï¸ Some smoke tests failed" -ForegroundColor Yellow
          }

      - name: Get service endpoints
        shell: pwsh
        run: |
          $namespace = "${{ env.KUBERNETES_NAMESPACE }}"
          
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## ðŸ”— Service Endpoints`n"
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "``````"
          kubectl get services -n $namespace | Add-Content -Path $env:GITHUB_STEP_SUMMARY
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "``````"

  # ============================================================================
  # PHASE 5: Deployment Summary
  # ============================================================================
  deployment-summary:
    needs: [prepare-deployment, deploy-to-staging, smoke-tests]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Deployment Summary
        run: |
          echo "## ðŸŽ‰ Deployment to Staging Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.prepare-deployment.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Git SHA:** ${{ needs.prepare-deployment.outputs.git-sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** Staging" >> $GITHUB_STEP_SUMMARY
          echo "**Namespace:** ${{ env.KUBERNETES_NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ Deployed Services:" >> $GITHUB_STEP_SUMMARY
          echo "- Auth Service" >> $GITHUB_STEP_SUMMARY
          echo "- User Service" >> $GITHUB_STEP_SUMMARY
          echo "- Product Service" >> $GITHUB_STEP_SUMMARY
          echo "- Order Service" >> $GITHUB_STEP_SUMMARY
          echo "- Payment Service" >> $GITHUB_STEP_SUMMARY
          echo "- Gateway" >> $GITHUB_STEP_SUMMARY
          echo "- Frontend" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. Verify services are running: \`kubectl get pods -n staging\`" >> $GITHUB_STEP_SUMMARY
          echo "2. Check logs: \`kubectl logs -n staging deployment/<service-name>\`" >> $GITHUB_STEP_SUMMARY
          echo "3. Access frontend: http://staging.electronic-paradise.local" >> $GITHUB_STEP_SUMMARY
          echo "4. Access API: http://api.staging.electronic-paradise.local" >> $GITHUB_STEP_SUMMARY
